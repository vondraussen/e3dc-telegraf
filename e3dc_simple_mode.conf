# this is for E3DC Simple Mode Modbus
# replace all variables (${XXX}) or create a env var file for
# telegraf (/etc/defaults/telegraf)

[[inputs.modbus]]
  name_override = "energy"
  name = "E3DC"
  slave_id = 1

  ## Timeout for each request
  timeout = "1s"
  
  # TCP - connect via Modbus/TCP
  controller = "tcp://172.21.0.45:502"

  holding_registers = [
    { name = "pv_power",      byte_order = "AB", data_type = "INT16",   scale=1.0, address = [67]},
    { name = "battery_power", byte_order = "AB", data_type = "INT16",   scale=1.0, address = [69]},
    { name = "home_usage",    byte_order = "AB", data_type = "INT16",   scale=1.0, address = [71]},
    { name = "grid_power",    byte_order = "AB", data_type = "INT16",   scale=1.0, address = [73]},
    { name = "autarcy",       byte_order = "AB", data_type = "INT16",   scale=1.0, address = [81]},
    { name = "battery_soc",   byte_order = "AB", data_type = "INT16",   scale=1.0, address = [82]},
    { name = "ems_status",    byte_order = "AB", data_type = "UINT16",  scale=1.0, address = [84]},
  ]
 
  [inputs.modbus.tags]                                                          
    influxdb_database = "energy"
    Location = "${LOCATION}"

[[processors.starlark]]
  namepass = ["energy"]
  source = '''
def apply(metric):
	grid_power = metric.fields.get("grid_power")
        if 0 < grid_power:
		metric.fields["grid_feed_power"] = 0
		metric.fields["grid_usage_power"] = abs(grid_power)
	if grid_power <= 0:
		metric.fields["grid_feed_power"] = abs(grid_power)
		metric.fields["grid_usage_power"] = 0

	battery_power = metric.fields.get("battery_power")
	if 0 < battery_power:
		metric.fields["battery_usage_power"] = 0
		metric.fields["battery_feed_power"] = abs(battery_power)	
	if battery_power <= 0:
		metric.fields["battery_usage_power"] = abs(battery_power)
		metric.fields["battery_feed_power"] = 0
	
	ownusage = metric.fields.pop("autarcy")
	metric.fields["ownusage"] = ownusage & 0xff
	metric.fields["autarcy"] = ownusage >> 8
	return metric
'''
